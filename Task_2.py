# Представьте себе очередь на кассе. К кассе подходит первый человек в очереди,
# а в конец очереди встает вновь пришедший.
# В программировании есть подобный тип данных - Queue (англ. "очередь"),
# основанный на принципе FIFO (англ. first in, first out «первым пришёл — первым ушёл»).
#
# Задание:
# Реализовать класс Queue
# Определить атрибут inside, который будет хранить в себе имена людей в очереди.
# Переопределить метод __str__, чтобы преобразовать его к виду: Name1=>Name2=>...=>Name3
#
# Реализовать методы:
# add - который добавляет имя в очередь
# take_out убирает первого человека из списка
# Переопределить методы __add__ , __sub__, __iadd__, __isub__ чтобы
# они соответствовали методам add и take_out

class Queue:
    def __init__(self, inside):
        self.inside = [inside]

    def add(self, i):
        self.inside.append(i)

    def take_out(self, i = 0):
        self.inside.pop(i)


    def __add__(self, i):
        self.add(i)

    def __sub__(self, other = 0):
        self.take_out()

    def __iadd__(self, i):
        self.add(i)
        return self

    def __isub__(self, other = 0):
        self.take_out()
        return self

    def __str__(self):
        return f"[{' -> '.join(map(str, self.inside))}]" if self.inside else "[]"

a = Queue('Миша')
print(f"Начальная очередь: {a}")

print('_______________________________________________________________________')

a + 'Даша'
a.__add__('Николай')
print(f"Пришли еще два человека в очередь: {a}")

print('_______________________________________________________________________')

a.__sub__()
print(f'Одного покупателя обслужили: {a}')

print('_______________________________________________________________________')

a.__iadd__('Арина')
a += 'Рита'
print(f"Пришли еще два человека в очередь: {a}")

print('_______________________________________________________________________')

a.__isub__()
print(f'Одного покупателя обслужили: {a}')